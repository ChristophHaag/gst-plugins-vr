#!/usr/bin/env python3

import signal
import os
import sys
import gi

gi.require_version('Gdk', '3.0')
gi.require_version('Gst', '1.0')
gi.require_version('Gtk', '3.0')
gi.require_version('GstVideo', '1.0')
gi.require_version('GstGL', '1.0')
gi.require_version('GnomeDesktop', '3.0')

from gi.repository import Gdk, Gst, Gtk, GdkX11, GstVideo, GstGL, GnomeDesktop, GLib
from sphvr.sinks import *
from collections import OrderedDict

from ctypes import cdll
try:
    x11 = cdll.LoadLibrary('libX11.so')
    x11.XInitThreads()
except OSError:
    pass


# Check if we're in development or installed version and set paths properly
def _in_devel():
    root_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    return os.path.exists(os.path.join(root_dir, '.git'))


def _add_sphvr_path():
    directory = os.path.dirname(os.path.abspath(__file__))
    if _in_devel():
        root = os.path.split(directory)[0]
    else:
        root = os.path.join('/usr/lib', 'sphvr', 'python')

    if not root in sys.path:
        sys.path.append(root)


class Monitor:
    def __init__(self):
        self.geometry = None
        self.physical = []
        self.product = ""
        self.vendor = ""
        self.display_name = ""

    def __str__(self):
        return " ".join(("%dx%d" % (self.geometry.width, self.geometry.height),
                         "%.1fcmx%.1fcm" % (self.physical[0], self.physical[1]),
                         self.vendor, self.product, self.display_name))


class SPHVR:
    def __init__(self):
        self.hmd_monitor = 0
        self.monitors = OrderedDict()
        self.pipeline = None

        if len(sys.argv) != 2:
            print("Usage:")
            print("       sphvr <uri>")
            print("Example:")
            print("       sphvr file:///home/bmonkey/Videos/elephants.webm")
            exit()
        else:
            self.video_uri = sys.argv[1]

        Gtk.init([])
        Gst.init([])

        self.init_monitors()
        # self.print_monitors()

        self.width, self.height = self.hmd_monitor.geometry.width, self.hmd_monitor.geometry.height
        self.is_fullscreen = False
        self.aspect = float(self.width)/float(self.height)

        self.hmd_sink = GstOverlaySink("glimagesink", self.width, self.height)
        self.desktop_sink = GstOverlaySink("glimagesink", self.width, self.height)

        self.init_pipeline()

        self.hmd_window = Gtk.Window()
        self.hmd_window.set_default_size(self.width, self.height)
        self.hmd_window.set_title("HMD")
        self.hmd_window.add(self.hmd_sink.widget)

        try:
            from gi.repository import GdkPixbuf
            pixbuf = GdkPixbuf.Pixbuf.new_from_file("data/sphvr.png")
            theme = Gtk.IconTheme.get_default()
            theme.add_builtin_icon("sphvr", 256, pixbuf)
            self.hmd_window.set_icon_name("sphvr")
        except GLib.Error:
            # no icon
            pass
        self.hmd_window.show_all()
        self.hmd_sink.set_handle()

        self.desktop_window = Gtk.Window()
        self.desktop_window.connect("delete-event", self.window_closed, self.pipeline)
        self.desktop_window.connect("key-press-event", self.key_pressed, self.pipeline)
        self.desktop_window.set_default_size(self.width, self.height)
        self.desktop_window.set_title("SPHVR")
        self.desktop_window.add(self.desktop_sink.widget)
        self.desktop_window.show_all()
        self.desktop_sink.set_handle()

        self.fullscreen_window_on_hmd(self.hmd_window)

        if self.pipeline.set_state(Gst.State.PLAYING) == Gst.StateChangeReturn.FAILURE:
            self.pipeline.set_state(Gst.State.NULL)
        else:
            Gtk.main()

    def fullscreen_window_on_hmd(self, window):
        screen = Gdk.Screen.get_default()
        window.move(self.hmd_monitor.geometry.x, self.hmd_monitor.geometry.y)
        window.fullscreen_on_monitor(screen, self.hmd_monitor.id)
        print("fullscreen on", self.hmd_monitor)

    @staticmethod
    def pad_added_cb(element, stuff, sink):
        element.link(sink)

    def quit_app(self):
        self.pipeline.set_state(Gst.State.NULL)
        Gtk.main_quit()

    def bus_cb(self, bus, message):
        if message.type == Gst.MessageType.EOS:
            print("eos")
            self.quit_app()
        elif message.type == Gst.MessageType.ERROR:
            print("Error:", message.parse_error())
            self.quit_app()

    def init_pipeline(self):
        self.pipeline = Gst.Pipeline()
        src = Gst.ElementFactory.make("uridecodebin", None)
        src.set_property("uri", self.video_uri)
        glupload = Gst.ElementFactory.make("glupload", None)
        glcolorconvert = Gst.ElementFactory.make("glcolorconvert", None)
        videorate = Gst.ElementFactory.make("videorate", None)
        vrcompositor = Gst.ElementFactory.make("vrcompositor", None)
        hmdwarp = Gst.ElementFactory.make("hmdwarp", None)

        tee = Gst.ElementFactory.make("tee", None)

        queue1 = Gst.ElementFactory.make("queue", None)
        queue2 = Gst.ElementFactory.make("queue", None)

        # caps
        caps = Gst.Caps.from_string("video/x-raw(memory:GLMemory), width=%d, height=%d, framerate=75/1" % (self.width, self.height))
        cf = Gst.ElementFactory.make("capsfilter")
        cf.set_property("caps", caps)

        self.pipeline.add(src, glupload, glcolorconvert, videorate)
        self.pipeline.add(vrcompositor, cf, hmdwarp, tee, queue1, queue2)
        self.pipeline.add(self.desktop_sink.element)
        self.pipeline.add(self.hmd_sink.element)
        src.link(glupload)
        glupload.link(glcolorconvert)
        glcolorconvert.link(videorate)
        videorate.link(vrcompositor)
        vrcompositor.link(cf)

        cf.link(hmdwarp)

        queue1.link(self.hmd_sink.element)
        queue2.link(self.desktop_sink.element)

        hmdwarp.link(tee)

        srcpadvideo = tee.get_request_pad("src_0")
        sinkpadvideo = queue1.get_static_pad("sink")
        srcpadvideo.link(sinkpadvideo)

        srcpadvideo = tee.get_request_pad("src_1")
        sinkpadvideo = queue2.get_static_pad("sink")
        srcpadvideo.link(sinkpadvideo)

        src.connect("pad-added", self.pad_added_cb, glupload)

        bus = self.pipeline.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.bus_cb)

    def init_monitors(self):
        screen = Gdk.Screen.get_default()
        for m in range(0, screen.get_n_monitors()):
            plug = screen.get_monitor_plug_name(m)

            mon = Monitor()
            mon.id = m

            self.monitors[plug] = mon

            mon.geometry = screen.get_monitor_geometry(m)
            # mon.output = screen.get_monitor_output(m)
            # mon.workarea = screen.get_monitor_workarea(m)
            mon.physical = [float(screen.get_monitor_height_mm(m)) / 10.0, float(screen.get_monitor_width_mm(m)) / 10.0]

        gscreen = GnomeDesktop.RRScreen.new(screen)
        gconfig = GnomeDesktop.RRConfig.new_current(gscreen)
        outputs = GnomeDesktop.RRConfig.get_outputs(gconfig)

        for info in outputs:
            plug = info.get_name()
            self.monitors[plug].vendor = info.get_vendor()
            self.monitors[plug].product = info.get_product()
            self.monitors[plug].display_name = info.get_display_name()
            if "Rift DK2" in self.monitors[plug].product:
                self.hmd_monitor = self.monitors[plug]

    def print_monitors(self):
        for k, v in self.monitors.items():
            print(k, v)

    def key_pressed(self, widget, key, pipeline):
        if key.keyval == Gdk.KEY_Escape:
            self.quit_app()

    @staticmethod
    def pause(button, pipeline, sink):
        if pipeline.get_state(Gst.CLOCK_TIME_NONE)[1] == Gst.State.PAUSED:
            pipeline.set_state(Gst.State.PLAYING)
        else:
            pipeline.set_state(Gst.State.PAUSED)

    def window_closed(self, widget, event, pipeline):
        self.quit_app()


signal.signal(signal.SIGINT, signal.SIG_DFL)
_add_sphvr_path()
SPHVR()


